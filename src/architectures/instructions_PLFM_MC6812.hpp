auto instructions_PLFM_MC6812 = flags_vector_t{
	TO_ENUM(MC12_null, "Undocumented instruction MC12_null"),
	TO_ENUM(MC12_aba, "Add B to A"),
	TO_ENUM(MC12_abx, "Add B to X"),
	TO_ENUM(MC12_aby, "Add B to Y"),
	TO_ENUM(MC12_adca, "Add with carry to A"),
	TO_ENUM(MC12_adcb, "Add with carry to B"),
	TO_ENUM(MC12_adda, "Add memory to A"),
	TO_ENUM(MC12_addb, "Add memory to B"),
	TO_ENUM(MC12_addd, "Add to D"),
	TO_ENUM(MC12_anda, "AND A with memory"),
	TO_ENUM(MC12_andb, "AND B with memory"),
	TO_ENUM(MC12_andcc, "Logical AND CCR with memory"),
	TO_ENUM(MC12_asl, "Arithmetic shift left memory"),
	TO_ENUM(MC12_asla, "Arithmetic shift left A"),
	TO_ENUM(MC12_aslb, "Arithmetic shift left B"),
	TO_ENUM(MC12_asld, "Arithmetic shift left D"),
	TO_ENUM(MC12_asr, "Arithmetic shift right memory"),
	TO_ENUM(MC12_asra, "Arithmetic shift right A"),
	TO_ENUM(MC12_asrb, "Arithmetic shift right B"),
	TO_ENUM(MC12_bcc, "Branch if carry clear"),
	TO_ENUM(MC12_bclr, "Clear bits in memory"),
	TO_ENUM(MC12_bcs, "Branch if carry set"),
	TO_ENUM(MC12_beq, "Branch if equal"),
	TO_ENUM(MC12_bge, "Branch if greater than or equal"),
	TO_ENUM(MC12_bgnd, "Enter background debug mode"),
	TO_ENUM(MC12_bgt, "Branch if greater than"),
	TO_ENUM(MC12_bhi, "Branch if higher"),
	TO_ENUM(MC12_bhs, "Branch if higher or same"),
	TO_ENUM(MC12_bita, "Bit test A"),
	TO_ENUM(MC12_bitb, "Bit test B"),
	TO_ENUM(MC12_ble, "Branch if less than or equal"),
	TO_ENUM(MC12_blo, "Branch if lower"),
	TO_ENUM(MC12_bls, "Branch if lower or same"),
	TO_ENUM(MC12_blt, "Branch if less than"),
	TO_ENUM(MC12_bmi, "Branch if minus"),
	TO_ENUM(MC12_bne, "Branch if not equal"),
	TO_ENUM(MC12_bpl, "Branch if plus"),
	TO_ENUM(MC12_bra, "Branch always"),
	TO_ENUM(MC12_brclr, "Branch if selected bits clear"),
	TO_ENUM(MC12_brn, "Branch never"),
	TO_ENUM(MC12_brset, "Branch if selected bits set"),
	TO_ENUM(MC12_bset, "Set bits in memory"),
	TO_ENUM(MC12_bsr, "Branch to subroutine"),
	TO_ENUM(MC12_bvc, "Branch if overflow clear"),
	TO_ENUM(MC12_bvs, "Branch if overflow set"),
	TO_ENUM(MC12_call, "Call subroutine in expanded memory"),
	TO_ENUM(MC12_cba, "Compare A to B"),
	TO_ENUM(MC12_clc, "Clear C bit"),
	TO_ENUM(MC12_cli, "Clear I bit"),
	TO_ENUM(MC12_clr, "Clear memory"),
	TO_ENUM(MC12_clra, "Clear A"),
	TO_ENUM(MC12_clrb, "Clear B"),
	TO_ENUM(MC12_clv, "Clear V bit"),
	TO_ENUM(MC12_cmpa, "Compare A to memory"),
	TO_ENUM(MC12_cmpb, "Compare B to memory"),
	TO_ENUM(MC12_com, "One's complement memory"),
	TO_ENUM(MC12_coma, "One's complement A"),
	TO_ENUM(MC12_comb, "One's complement B"),
	TO_ENUM(MC12_cpd, "Compare D to memory (16-bit)"),
	TO_ENUM(MC12_cps, "Compare SP to memory (16-bit)"),
	TO_ENUM(MC12_cpx, "Compare X to memory (16-bit)"),
	TO_ENUM(MC12_cpy, "Compare Y to memory (16-bit)"),
	TO_ENUM(MC12_daa, "Decimal adjust A"),
	TO_ENUM(MC12_dbeq, "Decrement counter and branch if = 0"),
	TO_ENUM(MC12_dbne, "Decrement counter and branch if != 0"),
	TO_ENUM(MC12_dec, "Decrement memory"),
	TO_ENUM(MC12_deca, "Decrement A"),
	TO_ENUM(MC12_decb, "Decrement B"),
	TO_ENUM(MC12_des, "Decrement SP"),
	TO_ENUM(MC12_dex, "Decrement X"),
	TO_ENUM(MC12_dey, "Decrement Y"),
	TO_ENUM(MC12_ediv, "32 by 16 divide (unsigned) Quotient->Y Remainder->D"),
	TO_ENUM(MC12_edivs, "32 by 16 divide (signed)  Quotient->Y Remainder->D"),
	TO_ENUM(MC12_emacs, "Multiply and accumulate (signed)"),
	TO_ENUM(MC12_emaxd, "MAX of two unsigned 16-bit values result to accumulator"),
	TO_ENUM(MC12_emaxm, "MAX of two unsigned 16-bit values result to memory"),
	TO_ENUM(MC12_emind, "MIN of two unsigned 16-bit values result to accumulator"),
	TO_ENUM(MC12_eminm, "MIN of two unsigned 16-bit values result to memory"),
	TO_ENUM(MC12_emul, "16 by 16 multiply (unsigned)"),
	TO_ENUM(MC12_emuls, "16 by 16 multiply (signed)"),
	TO_ENUM(MC12_eora, "Exclusive OR A with memory"),
	TO_ENUM(MC12_eorb, "Exclusive OR B with memory"),
	TO_ENUM(MC12_etbl, "16-bit table lookup and interpolate"),
	TO_ENUM(MC12_exg, "Exchange register to register"),
	TO_ENUM(MC12_fdiv, "16 by 16 fractional divide Remainder->D"),
	TO_ENUM(MC12_ibeq, "Increment counter and branch if = 0"),
	TO_ENUM(MC12_ibne, "Increment counter and branch if != 0"),
	TO_ENUM(MC12_idiv, "16 by 16 integer divide (unsigned) Remainder->D"),
	TO_ENUM(MC12_idivs, "16 by 16 integer divide (signed) Remainder->D"),
	TO_ENUM(MC12_inc, "Increment memory"),
	TO_ENUM(MC12_inca, "Increment A"),
	TO_ENUM(MC12_incb, "Increment B"),
	TO_ENUM(MC12_ins, "Increment SP"),
	TO_ENUM(MC12_inx, "Increment X"),
	TO_ENUM(MC12_iny, "Increment Y"),
	TO_ENUM(MC12_jmp, "Jump Address"),
	TO_ENUM(MC12_jsr, "Jump to subroutine"),
	TO_ENUM(MC12_lbcc, "Long branch if carry clear"),
	TO_ENUM(MC12_lbcs, "Long branch if carry set"),
	TO_ENUM(MC12_lbeq, "Long branch if equal"),
	TO_ENUM(MC12_lbge, "Long branch if greater than or equal"),
	TO_ENUM(MC12_lbgt, "Long branch if greater than"),
	TO_ENUM(MC12_lbhi, "Long branch if higher"),
	TO_ENUM(MC12_lbhs, "Long branch if higher or same"),
	TO_ENUM(MC12_lble, "Long branch if less than or equal"),
	TO_ENUM(MC12_lblo, "Long branch if lower"),
	TO_ENUM(MC12_lbls, "Long branch if lower or same"),
	TO_ENUM(MC12_lblt, "Long branch if less than"),
	TO_ENUM(MC12_lbmi, "Long branch if minus"),
	TO_ENUM(MC12_lbne, "Long branch if not equal"),
	TO_ENUM(MC12_lbpl, "Long branch if plus"),
	TO_ENUM(MC12_lbra, "Long branch always"),
	TO_ENUM(MC12_lbrn, "Long branch never"),
	TO_ENUM(MC12_lbvc, "Long branch if overflow clear"),
	TO_ENUM(MC12_lbvs, "Long branch if overflow set"),
	TO_ENUM(MC12_ldaa, "Load A"),
	TO_ENUM(MC12_ldab, "Load B"),
	TO_ENUM(MC12_ldd, "Load D"),
	TO_ENUM(MC12_lds, "Load SP"),
	TO_ENUM(MC12_ldx, "Load X"),
	TO_ENUM(MC12_ldy, "Load Y"),
	TO_ENUM(MC12_leas, "Load effective address into SP"),
	TO_ENUM(MC12_leax, "Load effective address into X"),
	TO_ENUM(MC12_leay, "Load effective address into Y"),
	TO_ENUM(MC12_lsl, "Logic shift left memory"),
	TO_ENUM(MC12_lsla, "Logic shift left A"),
	TO_ENUM(MC12_lslb, "Logic shift left B"),
	TO_ENUM(MC12_lsld, "Logic shift left D"),
	TO_ENUM(MC12_lsr, "Logic shift right memory"),
	TO_ENUM(MC12_lsra, "Logic shift right A"),
	TO_ENUM(MC12_lsrb, "Logic shift right B"),
	TO_ENUM(MC12_lsrd, "Logic shift right D"),
	TO_ENUM(MC12_maxa, "MAX of two unsigned 8-bit values result to accumulator"),
	TO_ENUM(MC12_maxm, "MAX of two unsigned 8-bit values result to memory"),
	TO_ENUM(MC12_mem, "Membership function"),
	TO_ENUM(MC12_mina, "MIN of two unsigned 8-bit values result to accumulator"),
	TO_ENUM(MC12_minm, "MIN of two unsigned 8-bit values result to memory"),
	TO_ENUM(MC12_movb, "Move byte (8-bit)"),
	TO_ENUM(MC12_movw, "Move word (16-bit)"),
	TO_ENUM(MC12_mul, "8 by 8 multiply (unsigned)"),
	TO_ENUM(MC12_neg, "Two's complement memory"),
	TO_ENUM(MC12_nega, "Two's complement A"),
	TO_ENUM(MC12_negb, "Two's complement B"),
	TO_ENUM(MC12_nop, "Null operation"),
	TO_ENUM(MC12_oraa, "OR A with memory"),
	TO_ENUM(MC12_orab, "OR B with memory"),
	TO_ENUM(MC12_orcc, "Logical OR CCR with memory"),
	TO_ENUM(MC12_psha, "Push A"),
	TO_ENUM(MC12_pshb, "Push B"),
	TO_ENUM(MC12_pshc, "Push CCR"),
	TO_ENUM(MC12_pshd, "Push D"),
	TO_ENUM(MC12_pshx, "Push X"),
	TO_ENUM(MC12_pshy, "Push Y"),
	TO_ENUM(MC12_pula, "Pull A"),
	TO_ENUM(MC12_pulb, "Pull B"),
	TO_ENUM(MC12_pulc, "Pull CCR"),
	TO_ENUM(MC12_puld, "Pull D"),
	TO_ENUM(MC12_pulx, "Pull X"),
	TO_ENUM(MC12_puly, "Pull Y"),
	TO_ENUM(MC12_rev, "MIN-MAX rule evaluation"),
	TO_ENUM(MC12_revw, "MIN-MAX rule evaluation"),
	TO_ENUM(MC12_rol, "Rotate left memory through carry"),
	TO_ENUM(MC12_rola, "Rotate left A through carry"),
	TO_ENUM(MC12_rolb, "Rotate left B through carry"),
	TO_ENUM(MC12_ror, "Rotate right memory through carry"),
	TO_ENUM(MC12_rora, "Rotate right A through carry"),
	TO_ENUM(MC12_rorb, "Rotate right B through carry"),
	TO_ENUM(MC12_rtc, "Return from call"),
	TO_ENUM(MC12_rti, "Return from interrupt"),
	TO_ENUM(MC12_rts, "Return from subroutine"),
	TO_ENUM(MC12_sba, "Subtract B from A"),
	TO_ENUM(MC12_sbca, "Subtract with borrow from A"),
	TO_ENUM(MC12_sbcb, "Subtract with borrow from B"),
	TO_ENUM(MC12_sec, "Set C bit"),
	TO_ENUM(MC12_sei, "Set I bit"),
	TO_ENUM(MC12_sev, "Set V bit"),
	TO_ENUM(MC12_sex, "Sign extend 8-Bit operand"),
	TO_ENUM(MC12_staa, "Store A"),
	TO_ENUM(MC12_stab, "Store B"),
	TO_ENUM(MC12_std, "Store D"),
	TO_ENUM(MC12_stop, "Stop"),
	TO_ENUM(MC12_sts, "Store SP"),
	TO_ENUM(MC12_stx, "Store X"),
	TO_ENUM(MC12_sty, "Store Y"),
	TO_ENUM(MC12_suba, "Subtract memory from A"),
	TO_ENUM(MC12_subb, "Subtract memory from B"),
	TO_ENUM(MC12_subd, "Subtract memory from D"),
	TO_ENUM(MC12_swi, "Software interrupt"),
	TO_ENUM(MC12_tab, "Transfer A to B"),
	TO_ENUM(MC12_tap, "Transfer A to CCR"),
	TO_ENUM(MC12_tba, "Transfer B to A"),
	TO_ENUM(MC12_tbeq, "Test counter and branch if = 0"),
	TO_ENUM(MC12_tbl, "8-bit table lookup and interpolate"),
	TO_ENUM(MC12_tbne, "Test counter and branch if != 0"),
	TO_ENUM(MC12_tfr, "Transfer register to register"),
	TO_ENUM(MC12_tpa, "Transfer CCR to A"),
	TO_ENUM(MC12_trap, "Unimplemented opcode interrupt"),
	TO_ENUM(MC12_tst, "Test memory for zero or minus"),
	TO_ENUM(MC12_tsta, "Test A for zero or minus"),
	TO_ENUM(MC12_tstb, "Test B for zero or minus"),
	TO_ENUM(MC12_tsx, "Transfer SP to X"),
	TO_ENUM(MC12_tsy, "Transfer SP to Y"),
	TO_ENUM(MC12_txs, "Transfer X to SP"),
	TO_ENUM(MC12_tys, "Transfer Y to SP"),
	TO_ENUM(MC12_wai, "Wait for interrupt"),
	TO_ENUM(MC12_wav, "Calculates numerator and denominator for weighted average calculation"),
	TO_ENUM(MC12_wavr, "Resumes execution of interrupted WAV instruction"),
	TO_ENUM(MC12_xgdx, "Exchange D with X"),
	TO_ENUM(MC12_xgdy, "Exchange D with Y"),
	TO_ENUM(MC12_skip1, "Skip one byte"),
	TO_ENUM(MC12_skip2, "Skip two bytes"),
	TO_ENUM(MC12_last, "Undocumented instruction MC12_last")
};
