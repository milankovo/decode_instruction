auto instructions_PLFM_H8 = flags_vector_t{
	TO_ENUM(H8_null, "Undocumented instruction H8_null"),
	TO_ENUM(H8_add, "Add binary"),
	TO_ENUM(H8_adds, "Add with sign extension"),
	TO_ENUM(H8_addx, "Add with extend carry"),
	TO_ENUM(H8_and, "Logical AND"),
	TO_ENUM(H8_andc, "Logical AND with control register"),
	TO_ENUM(H8_band, "Bit AND"),
	TO_ENUM(H8_bra, "Branch always"),
	TO_ENUM(H8_brn, "Branch never"),
	TO_ENUM(H8_bhi, "Branch if higher"),
	TO_ENUM(H8_bls, "Branch if lower or same"),
	TO_ENUM(H8_bcc, "Branch if carry clear (higher or same)"),
	TO_ENUM(H8_bcs, "Branch if carry set (lower)"),
	TO_ENUM(H8_bne, "Branch if not equal"),
	TO_ENUM(H8_beq, "Branch if equal"),
	TO_ENUM(H8_bvc, "Branch if overflow clear"),
	TO_ENUM(H8_bvs, "Branch if overflow set"),
	TO_ENUM(H8_bpl, "Branch if plus"),
	TO_ENUM(H8_bmi, "Branch if minus"),
	TO_ENUM(H8_bge, "Branch if greates or equal"),
	TO_ENUM(H8_blt, "Branch if less"),
	TO_ENUM(H8_bgt, "Branch if greater"),
	TO_ENUM(H8_ble, "Branch if less or equal"),
	TO_ENUM(H8_bclr, "Bit clear"),
	TO_ENUM(H8_biand, "Bit invert AND"),
	TO_ENUM(H8_bild, "Bit invert load"),
	TO_ENUM(H8_bior, "Bit invert OR"),
	TO_ENUM(H8_bist, "Bit invert store"),
	TO_ENUM(H8_bixor, "Bit invert XOR"),
	TO_ENUM(H8_bld, "Bit load"),
	TO_ENUM(H8_bnot, "Bit NOT"),
	TO_ENUM(H8_bor, "Bit OR"),
	TO_ENUM(H8_bset, "Bit set"),
	TO_ENUM(H8_bsr, "Branch to subroutine"),
	TO_ENUM(H8_bst, "Bit store"),
	TO_ENUM(H8_btst, "Bit test"),
	TO_ENUM(H8_bxor, "Bit XOR"),
	TO_ENUM(H8_clrmac, "Clear MAC register"),
	TO_ENUM(H8_cmp, "Compare"),
	TO_ENUM(H8_daa, "Decimal adjust add"),
	TO_ENUM(H8_das, "Decimal adjust subtract"),
	TO_ENUM(H8_dec, "Decrement"),
	TO_ENUM(H8_divxs, "Divide extended as signed"),
	TO_ENUM(H8_divxu, "Divide extended as unsigned"),
	TO_ENUM(H8_eepmov, "Move data to EEPROM"),
	TO_ENUM(H8_exts, "Extend as signed"),
	TO_ENUM(H8_extu, "Extend as unsigned"),
	TO_ENUM(H8_inc, "Increment"),
	TO_ENUM(H8_jmp, "Jump"),
	TO_ENUM(H8_jsr, "Jump to subroutine"),
	TO_ENUM(H8_ldc, "Load to control register"),
	TO_ENUM(H8_ldm, "Load to multiple registers"),
	TO_ENUM(H8_ldmac, "Load to MAC register"),
	TO_ENUM(H8_mac, "Multiply and accumulate"),
	TO_ENUM(H8_mov, "Move data"),
	TO_ENUM(H8_movfpe, "Move from peripheral with E clock"),
	TO_ENUM(H8_movtpe, "Move to peripheral with E clock"),
	TO_ENUM(H8_mulxs, "Multiply extend as signed"),
	TO_ENUM(H8_mulxu, "Multiply extend as unsigned"),
	TO_ENUM(H8_neg, "Negate"),
	TO_ENUM(H8_nop, "No operation"),
	TO_ENUM(H8_not, "Logical complement"),
	TO_ENUM(H8_or, "Logical OR"),
	TO_ENUM(H8_orc, "Logical OR with control register"),
	TO_ENUM(H8_pop, "Pop data from stack"),
	TO_ENUM(H8_push, "Push data on stack"),
	TO_ENUM(H8_rotl, "Rotate left"),
	TO_ENUM(H8_rotr, "Rotate right"),
	TO_ENUM(H8_rotxl, "Rotate with extend carry left"),
	TO_ENUM(H8_rotxr, "Rotate with extend carry right"),
	TO_ENUM(H8_rte, "Return from exception"),
	TO_ENUM(H8_rts, "Return from subroutine"),
	TO_ENUM(H8_shal, "Shift arithmetic left"),
	TO_ENUM(H8_shar, "Shift arithmetic right"),
	TO_ENUM(H8_shll, "Shift logical left"),
	TO_ENUM(H8_shlr, "Shift logical right"),
	TO_ENUM(H8_sleep, "Power down mode"),
	TO_ENUM(H8_stc, "Store from control register"),
	TO_ENUM(H8_stm, "Store from multiple registers"),
	TO_ENUM(H8_stmac, "Store from MAC register"),
	TO_ENUM(H8_sub, "Subtract binary"),
	TO_ENUM(H8_subs, "Subtract with sign extension"),
	TO_ENUM(H8_subx, "Subtract with extend carry"),
	TO_ENUM(H8_tas, "Test and set"),
	TO_ENUM(H8_trapa, "Trap always"),
	TO_ENUM(H8_xor, "Logical XOR"),
	TO_ENUM(H8_xorc, "Logical XOR with control register"),
	TO_ENUM(H8_rtel, "Returns from an exception, restoring data to multiple general registers"),
	TO_ENUM(H8_rtsl, "Returns from a subroutine, restoring data to multiple general registers"),
	TO_ENUM(H8_movmd, "Transfers a data block"),
	TO_ENUM(H8_movsd, "Transfers a data block with zero detection"),
	TO_ENUM(H8_bras, "Branch always after the next instruction (delay slot)"),
	TO_ENUM(H8_movab, "MOVe effective Address/B"),
	TO_ENUM(H8_movaw, "MOVe effective Address/W"),
	TO_ENUM(H8_moval, "MOVe effective Address/L"),
	TO_ENUM(H8_bsetne, "Bit SET if Not Equal"),
	TO_ENUM(H8_bseteq, "Bit SET if EQual"),
	TO_ENUM(H8_bclrne, "Bit CLeaR if Not Equal"),
	TO_ENUM(H8_bclreq, "Bit CLeaR if Equal"),
	TO_ENUM(H8_bstz, "Bit STore Zero flag"),
	TO_ENUM(H8_bistz, "Bit Invert STore Zero flag"),
	TO_ENUM(H8_bfld, "Bit Field LoaD"),
	TO_ENUM(H8_bfst, "Bit Field STore"),
	TO_ENUM(H8_muls, "MULtiply as Signed"),
	TO_ENUM(H8_divs, "DIVide as Signed"),
	TO_ENUM(H8_mulu, "MULtiply as Unsigned"),
	TO_ENUM(H8_divu, "DIVide as Unsigned"),
	TO_ENUM(H8_mulsu, "MULtiply as Signed"),
	TO_ENUM(H8_muluu, "MULtiply as Unsigned"),
	TO_ENUM(H8_brabc, "BRAnch if Bit Cleared"),
	TO_ENUM(H8_brabs, "BRAnch if Bit Set"),
	TO_ENUM(H8_bsrbc, "Branch to SubRoutine if Bit Cleared"),
	TO_ENUM(H8_bsrbs, "Branch to SubRoutine if Bit Set"),
	TO_ENUM(H8_last, "Undocumented instruction H8_last")
};
