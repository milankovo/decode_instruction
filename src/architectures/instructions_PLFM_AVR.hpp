auto instructions_PLFM_AVR = flags_vector_t{
	TO_ENUM(AVR_null, "Undocumented instruction AVR_null"),
	TO_ENUM(AVR_add, "Add without Carry"),
	TO_ENUM(AVR_adc, "Add with Carry"),
	TO_ENUM(AVR_adiw, "Add Immediate to Word"),
	TO_ENUM(AVR_sub, "Subtract without Carry"),
	TO_ENUM(AVR_subi, "Subtract Immediate"),
	TO_ENUM(AVR_sbc, "Subtract with Carry"),
	TO_ENUM(AVR_sbci, "Subtract Immediate with Carry"),
	TO_ENUM(AVR_sbiw, "Subtract Immediate from Word"),
	TO_ENUM(AVR_and, "Logical AND"),
	TO_ENUM(AVR_andi, "Logical AND with Immediate"),
	TO_ENUM(AVR_or, "Logical OR"),
	TO_ENUM(AVR_ori, "Logical OR with Immediate"),
	TO_ENUM(AVR_eor, "Exclusive OR"),
	TO_ENUM(AVR_com, "One's Complement"),
	TO_ENUM(AVR_neg, "Two's Complement"),
	TO_ENUM(AVR_sbr, "Set Bit(s) in Register"),
	TO_ENUM(AVR_cbr, "Clear Bit(s) in Register"),
	TO_ENUM(AVR_inc, "Increment"),
	TO_ENUM(AVR_dec, "Decrement"),
	TO_ENUM(AVR_tst, "Test for Zero or Minus"),
	TO_ENUM(AVR_clr, "Clear Register"),
	TO_ENUM(AVR_ser, "Set Register"),
	TO_ENUM(AVR_cp, "Compare"),
	TO_ENUM(AVR_cpc, "Compare with Carry"),
	TO_ENUM(AVR_cpi, "Compare with Immediate"),
	TO_ENUM(AVR_mul, "Multiply"),
	TO_ENUM(AVR_rjmp, "Relative Jump"),
	TO_ENUM(AVR_ijmp, "Indirect Jump to (Z)"),
	TO_ENUM(AVR_jmp, "Jump"),
	TO_ENUM(AVR_rcall, "Relative Call Subroutine"),
	TO_ENUM(AVR_icall, "Indirect Call to (Z)"),
	TO_ENUM(AVR_call, "Call Subroutine"),
	TO_ENUM(AVR_ret, "Subroutine Return"),
	TO_ENUM(AVR_reti, "Interrupt Return"),
	TO_ENUM(AVR_cpse, "Compare, Skip if Equal"),
	TO_ENUM(AVR_sbrc, "Skip if Bit in Register Cleared"),
	TO_ENUM(AVR_sbrs, "Skip if Bit in Register Set"),
	TO_ENUM(AVR_sbic, "Skip if Bit in I/O Register Cleared"),
	TO_ENUM(AVR_sbis, "Skip if Bit in I/O Register Set"),
	TO_ENUM(AVR_brbs, "Branch if Status Flag Set"),
	TO_ENUM(AVR_brbc, "Branch if Status Flag Cleared"),
	TO_ENUM(AVR_breq, "Branch if Equal"),
	TO_ENUM(AVR_brne, "Branch if Not Equal"),
	TO_ENUM(AVR_brcs, "Branch if Carry Set"),
	TO_ENUM(AVR_brcc, "Branch if Carry Cleared"),
	TO_ENUM(AVR_brsh, "Branch if Same or Higher"),
	TO_ENUM(AVR_brlo, "Branch if Lower"),
	TO_ENUM(AVR_brmi, "Branch if Minus"),
	TO_ENUM(AVR_brpl, "Branch if Plus"),
	TO_ENUM(AVR_brge, "Branch if Greater or Equal"),
	TO_ENUM(AVR_brlt, "Branch if Less Than"),
	TO_ENUM(AVR_brhs, "Branch if Half Carry Flag Set"),
	TO_ENUM(AVR_brhc, "Branch if Half Carry Flag Cleared"),
	TO_ENUM(AVR_brts, "Branch if T Flag Set"),
	TO_ENUM(AVR_brtc, "Branch if T Flag Cleared"),
	TO_ENUM(AVR_brvs, "Branch if Overflow Flag is Set"),
	TO_ENUM(AVR_brvc, "Branch if Overflow Flag is Cleared"),
	TO_ENUM(AVR_brie, "Branch if Interrupt Enabled"),
	TO_ENUM(AVR_brid, "Branch if Interrupt Disabled"),
	TO_ENUM(AVR_mov, "Copy Register"),
	TO_ENUM(AVR_ldi, "Load Immediate"),
	TO_ENUM(AVR_lds, "Load Direct"),
	TO_ENUM(AVR_ld, "Load Indirect"),
	TO_ENUM(AVR_ldd, "Load Indirect with Displacement"),
	TO_ENUM(AVR_sts, "Store Direct to SRAM"),
	TO_ENUM(AVR_st, "Store Indirect"),
	TO_ENUM(AVR_std, "Store Indirect with Displacement"),
	TO_ENUM(AVR_lpm, "Load Program Memory"),
	TO_ENUM(AVR_in, "In Port"),
	TO_ENUM(AVR_out, "Out Port"),
	TO_ENUM(AVR_push, "Push Register on Stack"),
	TO_ENUM(AVR_pop, "Pop Register from Stack"),
	TO_ENUM(AVR_lsl, "Logical Shift Left"),
	TO_ENUM(AVR_lsr, "Logical Shift Right"),
	TO_ENUM(AVR_rol, "Rotate Left Through Carry"),
	TO_ENUM(AVR_ror, "Rotate Right Through Carry"),
	TO_ENUM(AVR_asr, "Arithmetic Shift Right"),
	TO_ENUM(AVR_swap, "Swap Nibbles"),
	TO_ENUM(AVR_bset, "Flag Set"),
	TO_ENUM(AVR_bclr, "Flag Clear"),
	TO_ENUM(AVR_sbi, "Set Bit in I/O Register"),
	TO_ENUM(AVR_cbi, "Clear Bit in I/O Register"),
	TO_ENUM(AVR_bst, "Bit Store from Register to T"),
	TO_ENUM(AVR_bld, "Bit load from T to Register"),
	TO_ENUM(AVR_sec, "Set Carry"),
	TO_ENUM(AVR_clc, "Clear Carry"),
	TO_ENUM(AVR_sen, "Set Negative Flag"),
	TO_ENUM(AVR_cln, "Clear Negative Flag"),
	TO_ENUM(AVR_sez, "Set Zero Flag"),
	TO_ENUM(AVR_clz, "Clear Zero Flag"),
	TO_ENUM(AVR_sei, "Global Interrupt Enable"),
	TO_ENUM(AVR_cli, "Global Interrupt Disable"),
	TO_ENUM(AVR_ses, "Set Signed Test Flag"),
	TO_ENUM(AVR_cls, "Clear Signed Test Flag"),
	TO_ENUM(AVR_sev, "Set Two's Complement Overflow"),
	TO_ENUM(AVR_clv, "Clear Two's Complement Overflow"),
	TO_ENUM(AVR_set, "Set T in SREG"),
	TO_ENUM(AVR_clt, "Clear T in SREG"),
	TO_ENUM(AVR_seh, "Set Half Carry Flag in SREG"),
	TO_ENUM(AVR_clh, "Clear Half Carry Flag in SREG"),
	TO_ENUM(AVR_nop, "No Operation"),
	TO_ENUM(AVR_sleep, "Sleep"),
	TO_ENUM(AVR_wdr, "Watchdog Reset"),
	TO_ENUM(AVR_elpm, "Extended Load Program Memory"),
	TO_ENUM(AVR_espm, "Extended Store Program Memory"),
	TO_ENUM(AVR_fmul, "Fractional Multiply Unsigned"),
	TO_ENUM(AVR_fmuls, "Fractional Multiply Signed"),
	TO_ENUM(AVR_fmulsu, "Fractional Multiply Signed with Unsigned"),
	TO_ENUM(AVR_movw, "Copy Register Word"),
	TO_ENUM(AVR_muls, "Multiply Signed"),
	TO_ENUM(AVR_mulsu, "Multiply Signed with Unsigned"),
	TO_ENUM(AVR_spm, "Store Program Memory"),
	TO_ENUM(AVR_eicall, "Extended Indirect Call to Subroutine"),
	TO_ENUM(AVR_eijmp, "Extended Indirect Jump"),
	TO_ENUM(AVR_des, "Data Encryption Standard"),
	TO_ENUM(AVR_lac, "Load And Clear"),
	TO_ENUM(AVR_las, "Load And Set"),
	TO_ENUM(AVR_lat, "Load And Toggle"),
	TO_ENUM(AVR_xch, "Exchange"),
	TO_ENUM(AVR_last, "Undocumented instruction AVR_last")
};
