auto instructions_PLFM_8051 = flags_vector_t{
	TO_ENUM(I51_null, "Undocumented instruction I51_null"),
	TO_ENUM(I51_acall, "Absolute Call"),
	TO_ENUM(I51_add, "Add Second Operand to Acc"),
	TO_ENUM(I51_addc, "Add Second Operand to Acc with carry"),
	TO_ENUM(I51_ajmp, "Absolute Jump"),
	TO_ENUM(I51_anl, "Logical AND (op1 &= op2)"),
	TO_ENUM(I51_cjne, "Compare Operands and JNE"),
	TO_ENUM(I51_clr, "Clear Operand (0)"),
	TO_ENUM(I51_cpl, "Complement Operand"),
	TO_ENUM(I51_da, "Decimal Adjust Accumulator"),
	TO_ENUM(I51_dec, "Decrement Operand"),
	TO_ENUM(I51_div, "Divide Acc by B"),
	TO_ENUM(I51_djnz, "Decrement Operand and JNZ"),
	TO_ENUM(I51_inc, "Increment Operand"),
	TO_ENUM(I51_jb, "Jump if Bit is set"),
	TO_ENUM(I51_jbc, "Jump if Bit is set & clear Bit"),
	TO_ENUM(I51_jc, "Jump if Carry is set"),
	TO_ENUM(I51_jmp, "Jump indirect relative to Data Pointer"),
	TO_ENUM(I51_jnb, "Jump if Bit is clear"),
	TO_ENUM(I51_jnc, "Jump if Carry is clear"),
	TO_ENUM(I51_jnz, "Jump if Acc is not zero"),
	TO_ENUM(I51_jz, "Jump if Acc is zero"),
	TO_ENUM(I51_lcall, "Long Subroutine Call"),
	TO_ENUM(I51_ljmp, "Long Jump"),
	TO_ENUM(I51_mov, "Move (Op1 <- Op2)"),
	TO_ENUM(I51_movc, "Move code byte relative to second op to Acc"),
	TO_ENUM(I51_movx, "Move from/to external RAM"),
	TO_ENUM(I51_mul, "Multiply Acc by B"),
	TO_ENUM(I51_nop, "No operation"),
	TO_ENUM(I51_orl, "Logical OR (op1 |= op2)"),
	TO_ENUM(I51_pop, "Pop  from Stack and put in Direct RAM"),
	TO_ENUM(I51_push, "Push from Direct RAM to Stack"),
	TO_ENUM(I51_ret, "Return from subroutine"),
	TO_ENUM(I51_reti, "Return from Interrupt"),
	TO_ENUM(I51_rl, "Rotate Acc left"),
	TO_ENUM(I51_rlc, "Rotate Acc left through Carry"),
	TO_ENUM(I51_rr, "Rotate Acc right"),
	TO_ENUM(I51_rrc, "Rotate Acc right through Carry"),
	TO_ENUM(I51_setb, "Set Direct Bit"),
	TO_ENUM(I51_sjmp, "Short jump"),
	TO_ENUM(I51_subb, "Subtract Second Operand from Acc with Borrow"),
	TO_ENUM(I51_swap, "Swap nibbles of Acc"),
	TO_ENUM(I51_xch, "Exchange Operands"),
	TO_ENUM(I51_xchd, "Exchange Digit in Acc with Indirect RAM"),
	TO_ENUM(I51_xrl, "Exclusive OR (op1 ^= op2)"),
	TO_ENUM(I51_jsle, "Jump if less than or equal (signed)"),
	TO_ENUM(I51_jsg, "Jump if greater than (signed)"),
	TO_ENUM(I51_jle, "Jump if less than or equal"),
	TO_ENUM(I51_jg, "Jump if greater than"),
	TO_ENUM(I51_jsl, "Jump if less than (signed)"),
	TO_ENUM(I51_jsge, "Jump if greater than or equal (signed)"),
	TO_ENUM(I51_je, "Jump if equal"),
	TO_ENUM(I51_jne, "Jump if not equal"),
	TO_ENUM(I51_trap, "Trap"),
	TO_ENUM(I51_ejmp, "Extended jump"),
	TO_ENUM(I51_ecall, "Extended call"),
	TO_ENUM(I51_eret, "Extended return"),
	TO_ENUM(I51_movh, "Move immediate 16-bit data to the high word of a dword (double-word) register"),
	TO_ENUM(I51_movz, "Move 8-bit register to 16-bit register with zero extension"),
	TO_ENUM(I51_movs, "Move 8-bit register to 16-bit register with sign extension"),
	TO_ENUM(I51_srl, "Shift logical right by 1 bit"),
	TO_ENUM(I51_sra, "Shift arithmetic right by 1 bit"),
	TO_ENUM(I51_sll, "Shift logical left by 1 bit"),
	TO_ENUM(I51_sub, "Subtract"),
	TO_ENUM(I51_cmp, "Compare"),
	TO_ENUM(I51_emov, "Move (A <- @PRi+disp) or (@PRi+disp <- A)"),
	TO_ENUM(I51_last, "Undocumented instruction I51_last")
};
